\documentclass[a4paper]{article} % set paper size

\usepackage[utf8]{inputenc}
\usepackage {url}
\usepackage[top=2.0cm, bottom=2.0cm, left=2.54cm, right=2.54cm]{geometry} % set margin
\usepackage{amsfonts} % for set names
\usepackage{amsmath} % for equation system
\usepackage{amsthm} % for theorem block
\usepackage{fixltx2e} % for subscript
\usepackage{fancyhdr} % for footer/headline modification
\usepackage{xcolor}
\usepackage{graphicx,float} % for image insertion
\usepackage{multicol} %for text in tow columns

\usepackage{wrapfig} %figure wrapping


\pagestyle{fancyplain} % for footing modification on all pages
\fancyhf{}
%\renewcommand{\headrulewidth}{0pt} % remove decorative lign

\fancyhead[L]{Pauline Maury Laribiere\\
              Alexandre Devienne}
\fancyhead[R]{MT/EL-BA2 EPFL \\
                \today}
\fancyhead[C]{\textbf{Spring programming project : Microcosmos}}

\fancyfoot[R]{\thepage\ of \pageref{lastpage}}

\begin{document}
\begin{multicols*}{2}
% =====================================================================
\section{Program's architecture}


\begin{figure}[H]
\centering
\includegraphics[width=0.45\textwidth]{architecture.jpg}
\caption{Final architecture}
\end{figure}


Compared to the architecture suggested, we added two low level modules, and 2 depencies:
\begin{description}
\item[Module: geometry]
Low level representation of points and vectors and functions to manipulate them (ex: distance between points, norm of a vector)

%This module in included in the modules : \emph{main}, \emph{sim}, \emph{generateur}, \emph{particule}, \emph{trou\_noir}, \emph{graphic}.

\item[Module: linked\_list]
Abstract double linked list data structure.
Some basic dictionary are implemented such as : first, next, add, delete, search.
More complex operations exist such as : sorting and calling a function with 2 elements as argument , for every possible 2-combinations of elements
(to work out the forces between every particles for example)

%This module in included in the modules : \emph{sim}, \emph{generateur}, \emph{particule}, \emph{trou\_noir}.

\item[Dependency: trou\_noir $\rightarrow$ particule]
This allows \emph{trou\_noir} to call \texttt{part\_applyForceField( void (*forceFieldAt) (POINT p) )}
to apply the force generated by all black holes to all particles.
Plus, to destroy particles too close to a black hole, it can call \texttt{int part\_closestPartOn( POINT p )}
to retrieve a particle's ID to then destroy it with : \texttt{part\_delete( int partID )}

\item[Dependency: generateur $\rightarrow$ particule]
This allows \emph{generateur} to delegate the validity of a generator's argument to \emph{particule}
and to create particle by a simple call of \texttt{part\_create}
\end{description}

Working with these modules eases our work by reducing the amount of redundant code.
It also eased the testing part, as we could validate the correctness of these modules before using them in the project.

% =====================================================================
\section{Data structures}

To store the data from the particles, generators and black holes,
we used array of size MAX\_RENDU1 for the \emph{rendu1}.
But for the \emph{rendu 2} we needed a way to store large numbers of entities,
without any knowledge of the maximum amount.
We first consider arrays which double in size when full, but it had 2 drawbacks :
spikes (when the array is re-allocated) in calculation time
and a possibility that half the allocated memory isn't used.

This is why we went for \emph{linked list}.

To ease our work, we decided to use the same kind of data structure for all entities,
hence the abstract linked list module.

This module allowed us write complex 


% =====================================================================
\section{Function called by \emph{main.cpp} from \emph{sim.c}}
Here are the different functions of sim.c called in main.cpp :

\begin{itemize}
\item For file managment:
    \begin{itemize}
    \item sim\_openFile that manages the different mode supported bt the simulation
    \item sim\_save that saves the current state of the simulation in a file
    \end{itemize}
\item Getting information from the simulation:
    \begin{itemize}
    \item sim\_nbEntities updates the number of each entity
    \item sim\_extremPoints returns the outermost points at the beginning of the simulation to calculate the frame of the window to open
    \end{itemize}
\item Handling the advancement of the simulation
    \begin{itemize}
    \item sim\_display that calls the different entities to display them
    \item sim\_next\_step that handles calculation for the next step of the simulation
    \end{itemize}
\item Handling the user inputs:
    \begin{itemize}
    \item sim\_select enables the user of the program to select an entity
    \item sim\_deleteSelection to delete it
    \item sim\_unselect to unselect a selected entity
    \end{itemize}
\item Exiting a simulation:
    \begin{itemize}
    \item sim\_clean object is to free memory from all modules accross the simulation
    \end{itemize}
\end{itemize}



\label{lastpage}
\end{multicols*}
\end{document}
